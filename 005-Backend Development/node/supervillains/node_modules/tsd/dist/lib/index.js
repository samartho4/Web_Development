"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const path = require("path");
const readPkgUp = require("read-pkg-up");
const pathExists = require("path-exists");
const globby_1 = require("globby");
const compiler_1 = require("./compiler");
const config_1 = require("./config");
const rules_1 = require("./rules");
const findTypingsFile = (pkg, options) => __awaiter(this, void 0, void 0, function* () {
    const typings = pkg.types || pkg.typings || 'index.d.ts';
    const typingsExist = yield pathExists(path.join(options.cwd, typings));
    if (!typingsExist) {
        throw new Error(`The type definition \`${typings}\` does not exist. Create one and try again.`);
    }
    return typings;
});
const findTestFiles = (typingsFile, options) => __awaiter(this, void 0, void 0, function* () {
    const testFile = typingsFile.replace(/\.d\.ts$/, '.test-d.ts');
    const testDir = options.config.directory;
    const testFileExists = yield pathExists(path.join(options.cwd, testFile));
    const testDirExists = yield pathExists(path.join(options.cwd, testDir));
    if (!testFileExists && !testDirExists) {
        throw new Error(`The test file \`${testFile}\` does not exist. Create one and try again.`);
    }
    let testFiles = [testFile];
    if (!testFileExists) {
        testFiles = yield globby_1.default(`${testDir}/**/*.ts`, { cwd: options.cwd });
    }
    return testFiles;
});
/**
 * Type check the type definition of the project.
 *
 * @returns A promise which resolves the diagnostics of the type definition.
 */
exports.default = (options = { cwd: process.cwd() }) => __awaiter(this, void 0, void 0, function* () {
    const { pkg } = yield readPkgUp({ cwd: options.cwd });
    if (!pkg) {
        throw new Error('No `package.json` file found. Make sure you are running the command in a Node.js project.');
    }
    const config = config_1.default(pkg, options.cwd);
    // Look for a typings file, otherwise use `index.d.ts` in the root directory. If the file is not found, throw an error.
    const typingsFile = yield findTypingsFile(pkg, options);
    const testFiles = yield findTestFiles(typingsFile, Object.assign({}, options, { config }));
    const context = {
        cwd: options.cwd,
        pkg,
        typingsFile,
        testFiles,
        config
    };
    return [
        ...rules_1.default(context),
        ...compiler_1.getDiagnostics(context)
    ];
});
